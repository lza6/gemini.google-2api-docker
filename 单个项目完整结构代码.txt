é¡¹ç›® 'gemini-2api' çš„ç»“æ„æ ‘:
ğŸ“‚ gemini-2api/
    ğŸ“„ .env
    ğŸ“„ .env.example
    ğŸ“„ Dockerfile
    ğŸ“„ docker-compose.yml
    ğŸ“„ inject_session.py
    ğŸ“„ main.py
    ğŸ“„ nginx.conf
    ğŸ“„ requirements.txt
    ğŸ“‚ app/
        ğŸ“‚ core/
            ğŸ“„ __init__.py
            ğŸ“„ config.py
        ğŸ“‚ playwright_utils/
            ğŸ“„ initial_login.py
        ğŸ“‚ providers/
            ğŸ“„ __init__.py
            ğŸ“„ base_provider.py
            ğŸ“„ gemini_provider.py
        ğŸ“‚ utils/
            ğŸ“„ __init__.py
            ğŸ“„ sse_utils.py
    ğŸ“‚ debug/
================================================================================

--- æ–‡ä»¶è·¯å¾„: .env ---

# ====================================================================
# gemini-2api é…ç½®æ–‡ä»¶æ¨¡æ¿
# ====================================================================
#
# è¯·å°†æ­¤æ–‡ä»¶é‡å‘½åä¸º ".env" å¹¶å¡«å…¥æ‚¨çš„é…ç½®ã€‚
#

# --- æ ¸å¿ƒå®‰å…¨é…ç½® (å¿…é¡»è®¾ç½®) ---
# ç”¨äºä¿æŠ¤æ‚¨ API æœåŠ¡çš„è®¿é—®å¯†é’¥ã€‚
API_MASTER_KEY=1

# --- éƒ¨ç½²é…ç½® (å¯é€‰) ---
# Nginx å¯¹å¤–æš´éœ²çš„ç«¯å£
NGINX_PORT=8088

# --- Playwright æµè§ˆå™¨ä¸Šä¸‹æ–‡é…ç½® (å¿…é¡»è®¾ç½®) ---
# è¯·æä¾›ä¸€ä¸ªæˆ–å¤šä¸ªæŒä¹…åŒ–ä¸Šä¸‹æ–‡ç›®å½•çš„è·¯å¾„ã€‚æ¯ä¸ªç›®å½•ä»£è¡¨ä¸€ä¸ªç‹¬ç«‹çš„ Google ç™»å½•ä¼šè¯ã€‚
# 
# **é¦–æ¬¡è®¾ç½®æŒ‡å—:**
# 1. åœ¨æ‚¨çš„ä¸»æœºä¸Šåˆ›å»ºä¸€ä¸ªç›®å½•, ä¾‹å¦‚: `mkdir -p ./user_data_1`
# 2. åœ¨ä¸‹æ–¹å¡«å…¥è¯¥ç›®å½•çš„è·¯å¾„ã€‚
# 3. è¿è¡Œé¦–æ¬¡ç™»å½•è„šæœ¬: `docker-compose run --rm app python playwright_utils/initial_login.py ./user_data_1`
# 4. è„šæœ¬ä¼šå¯åŠ¨ä¸€ä¸ªæµè§ˆå™¨ï¼Œè¯·åœ¨å…¶ä¸­ç™»å½•æ‚¨çš„ Google è´¦æˆ·ï¼Œç„¶åå…³é—­æµè§ˆå™¨ã€‚
# 5. æ‚¨çš„ç™»å½•ä¼šè¯ç°å·²ä¿å­˜ã€‚ç°åœ¨å¯ä»¥æ­£å¸¸å¯åŠ¨æœåŠ¡: `docker-compose up -d`
#
PLAYWRIGHT_USER_DATA_DIR_1="./user_data_1"

# --- å¦‚éœ€å¯ç”¨å¤šè´¦å·è½®è¯¢ï¼Œè¯·å–æ¶ˆæ³¨é‡Šå¹¶ä¸ºæ¯ä¸ªè´¦å·é‡å¤ä¸Šè¿°è®¾ç½®æ­¥éª¤ ---
# PLAYWRIGHT_USER_DATA_DIR_2="./user_data_2"
# PLAYWRIGHT_USER_DATA_DIR_3="./user_data_3"

--- æ–‡ä»¶è·¯å¾„: .env.example ---

# ====================================================================
# gemini-2api é…ç½®æ–‡ä»¶æ¨¡æ¿
# ====================================================================
#
# è¯·å°†æ­¤æ–‡ä»¶é‡å‘½åä¸º ".env" å¹¶å¡«å…¥æ‚¨çš„é…ç½®ã€‚
#

# --- æ ¸å¿ƒå®‰å…¨é…ç½® (å¿…é¡»è®¾ç½®) ---
# ç”¨äºä¿æŠ¤æ‚¨ API æœåŠ¡çš„è®¿é—®å¯†é’¥ã€‚
API_MASTER_KEY=sk-gemini-2api-default-key-please-change-me

# --- éƒ¨ç½²é…ç½® (å¯é€‰) ---
# Nginx å¯¹å¤–æš´éœ²çš„ç«¯å£
NGINX_PORT=8088

# --- Playwright æµè§ˆå™¨ä¸Šä¸‹æ–‡é…ç½® (å¿…é¡»è®¾ç½®) ---
# è¯·æä¾›ä¸€ä¸ªæˆ–å¤šä¸ªæŒä¹…åŒ–ä¸Šä¸‹æ–‡ç›®å½•çš„è·¯å¾„ã€‚æ¯ä¸ªç›®å½•ä»£è¡¨ä¸€ä¸ªç‹¬ç«‹çš„ Google ç™»å½•ä¼šè¯ã€‚
# 
# **é¦–æ¬¡è®¾ç½®æŒ‡å—:**
# 1. åœ¨æ‚¨çš„ä¸»æœºä¸Šåˆ›å»ºä¸€ä¸ªç›®å½•, ä¾‹å¦‚: `mkdir -p ./user_data_1`
# 2. åœ¨ä¸‹æ–¹å¡«å…¥è¯¥ç›®å½•çš„è·¯å¾„ã€‚
# 3. è¿è¡Œé¦–æ¬¡ç™»å½•è„šæœ¬: `docker-compose run --rm app python playwright_utils/initial_login.py ./user_data_1`
# 4. è„šæœ¬ä¼šå¯åŠ¨ä¸€ä¸ªæµè§ˆå™¨ï¼Œè¯·åœ¨å…¶ä¸­ç™»å½•æ‚¨çš„ Google è´¦æˆ·ï¼Œç„¶åå…³é—­æµè§ˆå™¨ã€‚
# 5. æ‚¨çš„ç™»å½•ä¼šè¯ç°å·²ä¿å­˜ã€‚ç°åœ¨å¯ä»¥æ­£å¸¸å¯åŠ¨æœåŠ¡: `docker-compose up -d`
#
PLAYWRIGHT_USER_DATA_DIR_1="./user_data_1"

# --- å¦‚éœ€å¯ç”¨å¤šè´¦å·è½®è¯¢ï¼Œè¯·å–æ¶ˆæ³¨é‡Šå¹¶ä¸ºæ¯ä¸ªè´¦å·é‡å¤ä¸Šè¿°è®¾ç½®æ­¥éª¤ ---
# PLAYWRIGHT_USER_DATA_DIR_2="./user_data_2"
# PLAYWRIGHT_USER_DATA_DIR_3="./user_data_3"

--- æ–‡ä»¶è·¯å¾„: Dockerfile ---

# ä¿æŒè¿™ä¸ªç‰ˆæœ¬
FROM python:3.11-slim-bookworm AS final

# ç¯å¢ƒå˜é‡é…ç½®
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

# ----------------------------------------------------
# æ­¥éª¤ 1: ä»¥ ROOT èº«ä»½å®‰è£…æ‰€æœ‰ç³»ç»Ÿä¾èµ–å’Œ Python ä¾èµ–
# ----------------------------------------------------

# å®‰è£… Playwright è¿è¡Œæ‰€éœ€çš„ç³»ç»Ÿä¾èµ– (ä¿®æ­£ï¼šæ·»åŠ  libasound2)
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
    # Chromium è¿è¡Œæ—¶å¿…éœ€çš„ä¾èµ–
    libnss3 \
    libatk-bridge2.0-0 \
    libcups2 \
    libdrm-dev \
    libgbm-dev \
    libgdk-pixbuf-2.0-0 \
    libglib2.0-0 \
    libgtk-3-0 \
    libxcomposite1 \
    libxdamage1 \
    libxext6 \
    libxfixes3 \
    libxrandr2 \
    libxtst6 \
    # è§£å†³ç¼ºå¤±çš„å…±äº«åº“é”™è¯¯: libasound.so.2
    libasound2 \
    # å…¶ä»–å¸¸ç”¨æ„å»ºå’Œæƒé™å·¥å…·
    build-essential \
    sudo && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR /app

# å¤åˆ¶ requirements.txt å¹¶å®‰è£…åº”ç”¨ä¾èµ–
COPY requirements.txt .
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt

# ----------------------------------------------------
# æ­¥éª¤ 2: åˆ‡æ¢åˆ°é ROOT ç”¨æˆ·å¹¶å®‰è£… Playwright æµè§ˆå™¨
# ----------------------------------------------------

# å®‰å…¨æœ€ä½³å®è·µï¼šåˆ›å»º appuser
RUN useradd --create-home appuser || true 
# å°†æ•´ä¸ª /app ç›®å½•çš„æ‰€æœ‰æƒæˆäºˆ appuser (ç”± root æ‰§è¡Œ)
RUN chown -R appuser:appuser /app

# å¤åˆ¶åº”ç”¨ä»£ç  (åœ¨ root ç”¨æˆ·ä¸‹å¤åˆ¶)
COPY . .

# å…³é”®æƒé™ä¿®å¤ï¼šç¡®ä¿ debug ç›®å½•å­˜åœ¨å¹¶å±äº appuser
# æ³¨æ„ï¼šæˆ‘ä»¬å¿…é¡»åœ¨è¿™é‡Œç”± root åˆ›å»º debug ç›®å½•ï¼Œå¹¶æˆæƒ appuser è®¿é—®
RUN mkdir -p debug && chown appuser:appuser debug

# ç°åœ¨åˆ‡æ¢åˆ° appuser
USER appuser

# ä»¥ appuser èº«ä»½æ‰§è¡Œæµè§ˆå™¨ä¸‹è½½
RUN python -m playwright install chromium

# æš´éœ²ç«¯å£
EXPOSE 8000

# å¯åŠ¨å‘½ä»¤
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "1"]

--- æ–‡ä»¶è·¯å¾„: docker-compose.yml ---

services:
  nginx:
    image: nginx:latest
    container_name: gemini-2api-nginx
    restart: always
    ports:
      - "${NGINX_PORT:-8088}:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - app
    networks:
      - gemini-net

  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: gemini-2api-app
    restart: unless-stopped
    env_file:
      - .env
    # å…³é”®ï¼šåªä¿ç•™ debug ç›®å½•æŒ‚è½½ï¼Œç”¨äºå¯¼å‡ºæˆªå›¾å’Œæ—¥å¿—
    volumes:
      # - ./user_data_1:/app/user_data_1 # å·²ç§»é™¤ (çº¯åŒ¿åæ¨¡å¼)
      - ./debug:/app/debug  # ç¡®ä¿ debug ç›®å½•è¢«æŒ‚è½½å‡ºæ¥
    networks:
      - gemini-net

networks:
  gemini-net:
    driver: bridge

--- æ–‡ä»¶è·¯å¾„: inject_session.py ---

import asyncio
import json
import sys
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk, filedialog
from pathlib import Path
from typing import Dict, Any, Optional, Tuple, List
from urllib.parse import urlparse, parse_qs, unquote
import re
import queue
import threading
import os

# --- ä¾èµ–æ£€æŸ¥ ---
try:
    from playwright.async_api import async_playwright, BrowserContext
except ImportError:
    PLAYWRIGHT_INSTALLED = False
except Exception:
    PLAYWRIGHT_INSTALLED = False
else:
    PLAYWRIGHT_INSTALLED = True


# --- 0. æ ¸å¿ƒè¾…åŠ©å‡½æ•°ï¼šè¾“å…¥æ¸…ç†å’ŒæŸ¥æ‰¾ ---

def extract_best_json(text: str) -> Optional[Dict]:
    """
    ä»æ··ä¹±çš„æ–‡æœ¬ä¸­æå–æœ€å¤§/æœ€å¯èƒ½çš„æœ‰æ•ˆ JSON å¯¹è±¡ã€‚
    è§£å†³äº†ç›´æ¥æ­£åˆ™åŒ¹é…åœ¨åŒ…å«å¤šä¸ªèŠ±æ‹¬å·æˆ–æ—¥å¿—å¤´æ—¶å¤±è´¥çš„é—®é¢˜ã€‚
    """
    text = text.strip().replace('\ufeff', '')
    
    # 1. å°è¯•ç›´æ¥è§£æ
    try:
        return json.loads(text)
    except:
        pass

    # 2. å°è¯•å¯»æ‰¾æœ€å¤–å±‚çš„ {}
    starts = [m.start() for m in re.finditer(r'\{', text)]
    
    if not starts:
        return None

    # ä»æœ€æ—©çš„èµ·å§‹ç‚¹å¼€å§‹ï¼Œå°è¯•å¯»æ‰¾èƒ½è§£æçš„ JSON
    for start in starts:
        # å°è¯•åŒ¹é…åˆ°å­—ç¬¦ä¸²æœ«å°¾çš„æœ€åä¸€ä¸ª }
        end_search = text.rfind('}')
        if end_search == -1 or end_search < start:
            continue
            
        candidate_str = text[start : end_search + 1]
        
        # ä¼˜åŒ–ï¼šå°è¯•å»é™¤ JSON ä¹‹å‰çš„ BOM æˆ–å…¶ä»–é JSON å­—ç¬¦
        if candidate_str.startswith(')]}\''):
            candidate_str = candidate_str[4:]
        
        try:
            data = json.loads(candidate_str)
            # ç¡®ä¿æ˜¯å­—å…¸ç±»å‹
            if isinstance(data, dict):
                return data 
        except:
            continue
            
    return None

def parse_cookies_from_header_list(headers: List[Dict]) -> Dict[str, str]:
    """ä» HAR æ ¼å¼çš„ headers åˆ—è¡¨ä¸­æå– Cookie"""
    cookie_str = ""
    for header in headers:
        # å¿½ç•¥å¤§å°å†™æŸ¥æ‰¾ 'Cookie' å¤´
        if header.get('name', '').lower() == 'cookie':
            cookie_str = header.get('value', '')
            break
    return parse_cookies_from_string(cookie_str)

def parse_cookies_from_string(cookie_string: str) -> Dict[str, str]:
    """ä» Cookie å­—ç¬¦ä¸²ä¸­æå–å…³é”® Cookieã€‚"""
    if not cookie_string:
        return {}
        
    # å¢åŠ æ›´å¤šç›¸å…³çš„ Cookie åç§°ä»¥æé«˜æˆåŠŸç‡
    required_names = [
        "__Secure-1PSID", "__Secure-3PSID",
        "__Secure-1PSIDTS", "__Secure-3PSIDTS",
        "SID", "HSID", "SSID", "APISID", "SAPISID",
        "__Secure-1PAPISID", "__Secure-3PAPISID",
        "__Secure-ENID", "AEC", "NID",
        "SIDCC", "__Secure-1PSIDCC", "__Secure-3PSIDCC",
    ]
    
    cookies = {}
    # å¤„ç†å¯èƒ½çš„åˆ†éš”ç¬¦ï¼šåˆ†å·åå¯èƒ½è·Ÿç©ºæ ¼ï¼Œä¹Ÿå¯èƒ½æ²¡æœ‰
    parts = cookie_string.split(';')
    for pair in parts:
        if '=' in pair:
            name, value = pair.split('=', 1)
            name = name.strip()
            value = value.strip()
            
            # åªéœ€è¦åŒ…å«åœ¨ required_names ä¸­çš„ Cookie
            if name in required_names:
                cookies[name] = value
            # é¢å¤–å¤„ç†ï¼šå¦‚æœç”¨æˆ·åªç²˜è´´äº†æœ€é‡è¦çš„ 1PSID/3PSID/TS 
            elif name.startswith('__Secure-') and ('PSID' in name or 'TS' in name):
                 cookies[name] = value
                 
    # ä»…è¿”å›éœ€è¦çš„æœ€å°é›†åˆ
    final_cookies = {}
    for name in required_names:
        if name in cookies:
            final_cookies[name] = cookies[name]
            
    # ç¡®ä¿æœ€é‡è¦çš„å‡ ä¸ª Cookie å­˜åœ¨
    minimal_required = ["__Secure-1PSID", "__Secure-3PSID", "__Secure-1PSIDTS", "__Secure-3PSIDTS"]
    
    # å†æ¬¡éå†ï¼Œç¡®ä¿åªåŒ…å«å…³é”®çš„ PSID/PSIDTS
    final_filtered_cookies = {k: v for k, v in final_cookies.items() if k in minimal_required or ('PSID' in k or 'TS' in k)}

    return final_filtered_cookies

# --- 1. æ ¸å¿ƒè§£æé€»è¾‘ (åœ¨çº¿ç¨‹æ± ä¸­è¿è¡Œ) ---

def _sync_parse_text_segments(text_content: str) -> Tuple[bool, Optional[Dict], str]:
    """åŒæ­¥è§£æéæ ‡å‡†åˆ†æ®µæ–‡æœ¬ï¼Œå¹¶è¿”å›æ—¥å¿—ã€‚"""
    log_messages = ["-> å°è¯•ä½¿ç”¨éæ ‡å‡†åˆ†æ®µæ–‡æœ¬/æ­£åˆ™è§£æ..."]
    
    # 1. æå– URL (f.sid)
    url_match = re.search(r'(https?://[^\s]*(?:StreamGenerate|StreamGenerate\?)[^\s]*)', text_content)
    f_sid = None
    
    if url_match:
        full_url = url_match.group(1)
        log_messages.append(f"    [æˆåŠŸ] æå–åˆ° URL: {full_url[:60]}...")
        url_parsed = urlparse(full_url)
        query_params = parse_qs(url_parsed.query)
        f_sid = query_params.get('f.sid', [None])[0]
    else:
        # å¤‡ç”¨ï¼šç›´æ¥åœ¨æ–‡æœ¬ä¸­æœç´¢ f.sid
        sid_match = re.search(r'f\.sid\s*[:=]\s*([-0-9]+)', text_content)
        if sid_match:
             f_sid = sid_match.group(1)
             log_messages.append(f"    [æˆåŠŸ] ç›´æ¥æ­£åˆ™æå–åˆ° f.sid: {f_sid}")

    # 2. æå– at å‚æ•°
    at_param = None
    at_match = re.search(r'at=([^&\s]+)', text_content)
    if not at_match:
        at_match = re.search(r'at\s*[:=]\s*([^\s"]+)', text_content)
    
    if at_match:
        raw_at = at_match.group(1).strip()
        if '%' in raw_at and raw_at.startswith('A'):
            at_param = unquote(raw_at)
        else:
            at_param = raw_at
    
    # 3. æå– Cookie
    cookie_header_value = ""
    cookie_match = re.search(r'(?:Cookie|cookie):\s*([^\r\n]+)', text_content, re.IGNORECASE)
    if cookie_match:
        cookie_header_value = cookie_match.group(1).strip()
    elif 'SID=' in text_content and '__Secure-1PSID=' in text_content:
        # å¦‚æœç”¨æˆ·åªç²˜è´´äº† Cookie å­—ç¬¦ä¸²
         cookie_header_value = text_content 

    extracted_cookies = parse_cookies_from_string(cookie_header_value)


    if not f_sid or not at_param:
        log_messages.append(f"    [å¤±è´¥] åŠ¨æ€å‚æ•°æå–ä¸å®Œæ•´ (fSid found: {bool(f_sid)}, at found: {bool(at_param)})ã€‚")
        return (False, None, "\n".join(log_messages))
    
    log_messages.append(f"    [æˆåŠŸ] æå–åˆ° f.sid å’Œ at åŠ¨æ€å‚æ•°ã€‚")
    log_messages.append(f"    [çŠ¶æ€] æå–åˆ° {len(extracted_cookies)} ä¸ªå…³é”® Cookieã€‚")
    
    if len(extracted_cookies) == 0:
        log_messages.append("    [âš ï¸ è­¦å‘Š] æœªèƒ½æå–åˆ°å…³é”® Cookieã€‚")
    
    return (True, {
        "cookies": extracted_cookies,
        "dynamicParams": {
            "fSid": f_sid,
            "at": at_param
        }
    }, "\n".join(log_messages))


def _sync_parse_har_data(har_content: str) -> Tuple[bool, Optional[Dict], str]:
    """åŒæ­¥è§£æ HAR æ–‡ä»¶å†…å®¹ï¼Œå¹¶è¿”å›æ—¥å¿—ã€‚"""
    log_messages = ["-> å°è¯•ä½¿ç”¨æ ‡å‡† HAR/JSON è§£æ..."]
    
    data = extract_best_json(har_content)
    if not data:
        log_messages.append("    [å¤±è´¥] æœªæ‰¾åˆ°æœ‰æ•ˆçš„ JSON ç»“æ„ã€‚")
        return (False, None, "\n".join(log_messages))
        
    target_entry = None
    
    # é€’å½’æŸ¥æ‰¾åŒ…å«ç‰¹å®š URL çš„ request å¯¹è±¡
    def find_entry(obj):
        if isinstance(obj, dict):
            if 'url' in obj and ('/StreamGenerate' in obj['url'] or 'f.sid' in obj['url']):
                return obj
            if 'request' in obj:
                res = find_entry(obj['request'])
                if res: return res
            
            for key, value in obj.items():
                if isinstance(value, (dict, list)):
                    res = find_entry(value)
                    if res: return res
        elif isinstance(obj, list):
            for item in obj:
                res = find_entry(item)
                if res: return res
        return None

    # ä¼˜å…ˆæ£€æŸ¥æ ‡å‡†çš„ log -> entries ç»“æ„
    if isinstance(data, dict) and 'log' in data and 'entries' in data['log']:
        for entry in reversed(data['log']['entries']):
            if 'request' in entry and 'url' in entry['request']:
                if '/StreamGenerate' in entry['request']['url'] and entry['request'].get('method') == 'POST':
                    target_entry = entry['request']
                    break
    
    if not target_entry:
        target_entry = find_entry(data)

    if not target_entry:
        log_messages.append("    [å¤±è´¥] æœªæ‰¾åˆ° StreamGenerate API è¯·æ±‚è®°å½•ã€‚")
        return (False, None, "\n".join(log_messages)) 
    
    log_messages.append("    [æˆåŠŸ] æ‰¾åˆ°ç›®æ ‡ API è¯·æ±‚è®°å½•ã€‚")

    # 1. æå– f.sid
    url_parsed = urlparse(target_entry.get('url', ''))
    query_params = parse_qs(url_parsed.query)
    f_sid = query_params.get('f.sid', [None])[0]
    
    # 2. æå– at
    at_param = None
    post_data = target_entry.get('postData', {})
    if post_data.get('text'):
        text_data = post_data.get('text', '')
        if 'application/x-www-form-urlencoded' in post_data.get('mimeType', ''):
             params = parse_qs(text_data)
             at_param_encoded = params.get('at', [None])[0]
             at_param = unquote(at_param_encoded) if at_param_encoded else None
        
        if not at_param:
            at_match = re.search(r'at=([^&]+)', text_data)
            if at_match:
                 at_param = unquote(at_match.group(1))

    # 3. æå– Cookies
    extracted_cookies = {}
    if 'headers' in target_entry:
        # ä½¿ç”¨è¾…åŠ©å‡½æ•°è§£æ headers åˆ—è¡¨
        extracted_cookies = parse_cookies_from_header_list(target_entry['headers'])
    elif 'cookies' in target_entry and isinstance(target_entry['cookies'], list):
        # å¤„ç† HAR ä¸­ cookies å­—æ®µæ˜¯åˆ—è¡¨çš„æƒ…å†µ
        temp_cookie_str = ""
        for c in target_entry['cookies']:
             temp_cookie_str += f"{c['name']}={c['value']}; "
        extracted_cookies = parse_cookies_from_string(temp_cookie_str)


    if not f_sid or not at_param:
        log_messages.append(f"    [å¤±è´¥] åŠ¨æ€å‚æ•°æå–ä¸å®Œæ•´ (fSid: {f_sid}, at: {at_param})ã€‚")
        return (False, None, "\n".join(log_messages)) 
    log_messages.append(f"    [æˆåŠŸ] æå–åˆ° f.sid å’Œ at åŠ¨æ€å‚æ•°ã€‚")
    log_messages.append(f"    [çŠ¶æ€] æå–åˆ° {len(extracted_cookies)} ä¸ªå…³é”® Cookieã€‚")

    if len(extracted_cookies) == 0:
        log_messages.append("    [âš ï¸ è­¦å‘Š] è¯·æ±‚å¤´ä¸­æœªå‘ç°å…³é”® Cookieï¼")
        
    return (True, {
        "cookies": extracted_cookies,
        "dynamicParams": {
            "fSid": f_sid,
            "at": at_param
        }
    }, "\n".join(log_messages))


def _sync_parse_manual_json(raw_text: str) -> Tuple[bool, Optional[Dict], str]:
    """å°è¯•ä½œä¸ºæ‰‹åŠ¨ç²˜è´´çš„ä¼šè¯ JSON ç»“æ„è§£æã€‚"""
    log_messages = ["-> å°è¯•ä½œä¸ºæ‰‹åŠ¨ä¼šè¯ JSON è§£æ..."]
    
    manual_json_data = None
    try:
        temp_data = extract_best_json(raw_text)
        if temp_data and isinstance(temp_data, dict):
            if temp_data.get('cookies') and temp_data.get('dynamicParams') and temp_data['dynamicParams'].get('fSid'):
                manual_json_data = temp_data
                if len(manual_json_data['cookies']) == 0:
                    log_messages.append("    [è­¦å‘Š] æ‰‹åŠ¨ JSON ç»“æ„å®Œæ•´ï¼Œä½† Cookie åˆ—è¡¨ä¸ºç©ºã€‚")
                
                log_messages.append("    [æˆåŠŸ] è¯†åˆ«ä¸ºæœ‰æ•ˆçš„ä¼šè¯ JSON ç»“æ„ã€‚")
            else:
                log_messages.append("    [å¤±è´¥] ç»“æ„ä¸å®Œæ•´ (ç¼ºå°‘ cookies æˆ– dynamicParams/fSid)ã€‚")
                return (False, None, "\n".join(log_messages))
        else:
            log_messages.append("    [å¤±è´¥] æœªæ‰¾åˆ° JSON ç»“æ„ã€‚")
            return (False, None, "\n".join(log_messages))
    except Exception as e:
        log_messages.append(f"    [å¤±è´¥] JSON è§£æé”™è¯¯: {e}")
        return (False, None, "\n".join(log_messages))
    
    return (True, manual_json_data, "\n".join(log_messages))


def _sync_parse_and_validate(raw_text: str) -> Tuple[bool, Optional[Dict], str]:
    """
    åŒæ­¥å‡½æ•°ï¼šå°è¯•æ‰€æœ‰è§£ææ–¹æ³•ï¼Œè¿”å›ç»“æœå’Œè¯¦ç»†æ—¥å¿—ã€‚
    """
    
    # 1. å°è¯• HAR æ–‡ä»¶/JSON è¯·æ±‚è§£æ (æœ€ä¼˜å…ˆ)
    parsed_from_har = _sync_parse_har_data(raw_text)
    if parsed_from_har[0]:
        return (True, parsed_from_har[1], parsed_from_har[2] + "\nâœ… æå–æˆåŠŸ! (æ ¼å¼: HAR/JSON)")

    # 2. å°è¯•æ‰‹åŠ¨ç²˜è´´çš„ä¼šè¯ JSON ç»“æ„è§£æ
    parsed_from_manual = _sync_parse_manual_json(raw_text)
    if parsed_from_manual[0]:
        return (True, parsed_from_manual[1], parsed_from_manual[2] + "\nâœ… æå–æˆåŠŸ! (æ ¼å¼: æ‰‹åŠ¨ JSON)")

    # 3. å°è¯•æ‰‹åŠ¨ç²˜è´´çš„åˆ†æ®µæ–‡æœ¬è§£æ (æ­£åˆ™å…œåº•ï¼Œå…¼å®¹ cURL/Request Headers æ ¼å¼)
    parsed_from_segments = _sync_parse_text_segments(raw_text)
    if parsed_from_segments[0]:
        return (True, parsed_from_segments[1], parsed_from_segments[2] + "\nâœ… æå–æˆåŠŸ! (æ ¼å¼: æ­£åˆ™æ–‡æœ¬)")
    
    # å…¨éƒ¨å¤±è´¥ï¼Œç»„åˆè¯¦ç»†æ—¥å¿—
    final_log = "\n--- âŒ æå–å¤±è´¥ï¼šè¯¦ç»†è§£ææ—¥å¿— ---\n" + \
                "--- 1. HAR/JSON è§£æå°è¯• --- \n" + parsed_from_har[2] + "\n" + \
                "--- 2. æ‰‹åŠ¨ JSON è§£æå°è¯• --- \n" + parsed_from_manual[2] + "\n" + \
                "--- 3. åˆ†æ®µæ–‡æœ¬è§£æå°è¯• --- \n" + parsed_from_segments[2] + "\n"
    
    return (False, None, final_log + "\nâŒ ç²˜è´´çš„å†…å®¹è§£æå¤±è´¥ã€‚è¯·ç¡®ä¿æ‚¨ç²˜è´´äº†åŒ…å« StreamGenerate è¯·æ±‚çš„å®Œæ•´å†…å®¹ã€‚")


# --- 2. Playwright æ³¨å…¥é€»è¾‘ (I/O å¯†é›†å‹) ---

def normalize_path(path_str: str) -> str:
    """æ ‡å‡†åŒ–è·¯å¾„ï¼Œå»é™¤å†—ä½™çš„ ./ï¼Œå¹¶è½¬æ¢ä¸ºæ­£æ–œæ """
    return Path(path_str).resolve().as_posix()

def get_next_available_dir(base_path: Path) -> str:
    """æ£€æµ‹ä¸‹ä¸€ä¸ªå¯ç”¨çš„ user_data_X ç›®å½•ï¼Œä» 1 å¼€å§‹ã€‚"""
    i = 1
    while True:
        target_dir = base_path / f"user_data_{i}"
        # å¦‚æœç›®å½•ä¸å­˜åœ¨ï¼Œæˆ–è€…ç›®å½•æ˜¯ç©ºçš„ï¼Œæˆ–è€…ä¸åŒ…å« Playwright/Chrome çš„é»˜è®¤é…ç½®æ–‡ä»¶ï¼Œåˆ™è®¤ä¸ºå¯ç”¨
        if not target_dir.exists() or not (target_dir / "Default").exists():
            return f"./user_data_{i}" 
        else:
            i += 1
            if i > 50: 
                raise RuntimeError("æ£€æµ‹åˆ°è¶…è¿‡ 50 ä¸ªä¼šè¯ç›®å½•ï¼Œè¯·æ‰‹åŠ¨æ¸…ç†ã€‚")

async def inject_cookies_to_context(
    user_data_dir: str,
    session_data: Dict[str, Any],
    log_queue: queue.Queue 
) -> Tuple[bool, str]:
    """
    æ‰§è¡Œ Playwright æ³¨å…¥æ“ä½œã€‚
    :return: (æ˜¯å¦æˆåŠŸ, æœ€ç»ˆæ—¥å¿—)
    """
    final_logs = []
    
    def log_async(message, is_error=False):
        """å°†æ—¥å¿—æ¨é€åˆ°é˜Ÿåˆ—ï¼Œä»¥ä¾¿ä¸»çº¿ç¨‹å®‰å…¨æ‰“å°"""
        log_queue.put((message, is_error))
        final_logs.append(message) 

    if not PLAYWRIGHT_INSTALLED:
        log_async("âŒ Playwright ä¾èµ–ç¼ºå¤±æˆ–å¯åŠ¨å¤±è´¥ã€‚è¯·å…ˆå®‰è£…ä¾èµ–ã€‚", is_error=True)
        return (False, "\n".join(final_logs))
        
    normalized_dir = normalize_path(user_data_dir)
    log_async(f"\n--- æ³¨å…¥ä¼šè¯å¼€å§‹ ({normalized_dir}) ---", is_error=False)
    
    Path(normalized_dir).mkdir(parents=True, exist_ok=True)

    domain = session_data.get('cookieDomain', ".google.com")
    path = session_data.get('cookiePath', "/")
    
    cookies_to_inject = []
    current_cookie_count = len(session_data['data']['cookies'])
    
    # å¼ºåˆ¶æ£€æŸ¥æœ€é‡è¦çš„å››ä¸ª
    minimal_cookies_found = [k for k in session_data['data']['cookies'].keys() if k in ["__Secure-1PSID", "__Secure-3PSID", "__Secure-1PSIDTS", "__Secure-3PSIDTS"]]
    
    if len(minimal_cookies_found) == 0:
        log_async("âš ï¸ ä¸¥é‡è­¦å‘Š: æœªæå–åˆ°ä»»ä½• **å…³é”®** Cookieï¼", is_error=True)
        log_async("âš ï¸ æ³¨å…¥å°†ç»§ç»­ï¼Œä½†æ²¡æœ‰å…³é”® Cookieï¼ŒGemini æœåŠ¡æå¤§æ¦‚ç‡æ— æ³•å·¥ä½œã€‚", is_error=True)
        log_async("âš ï¸ è¯·é‡æ–°å¯¼å‡º HAR æˆ–è¯·æ±‚å¤´ï¼Œç¡®ä¿åŒ…å« **PSID** å’Œ **PSIDTS** Cookieã€‚", is_error=True)
    else:
        log_async(f"  - å‘ç° {current_cookie_count} ä¸ª Cookie (åŒ…å« {len(minimal_cookies_found)} ä¸ªå…³é”® Cookie)ï¼Œå‡†å¤‡å†™å…¥...", is_error=False)
    
    for name, value in session_data['data']['cookies'].items():
        cookies_to_inject.append({
            'name': name,
            'value': value,
            'domain': domain,
            'path': path,
            'secure': True,
            'httpOnly': True,
            'expires': -1 
        })
        log_async(f"  - å‡†å¤‡ Cookie: {name}", is_error=False)
    
    fSid = session_data['data']['dynamicParams'].get('fSid')
    at_param = session_data['data']['dynamicParams'].get('at')
    
    if not fSid or not at_param:
          log_async(f"âš ï¸ è­¦å‘Š: åŠ¨æ€å‚æ•° (fSid/at) ç¼ºå¤±ã€‚æœåŠ¡å¯èƒ½æ— æ³•å·¥ä½œã€‚", is_error=True)
    else:
        log_async(f"  - åŠ¨æ€å‚æ•°å®Œæ•´: f.sid={fSid}, at={at_param[:10]}...", is_error=False)


    try:
        async with async_playwright() as p:
            log_async("  - å¯åŠ¨ Playwright æµè§ˆå™¨ä¸Šä¸‹æ–‡...", is_error=False)
            context: BrowserContext = await p.chromium.launch_persistent_context(
                user_data_dir=normalized_dir,
                headless=True,
                args=['--no-sandbox', '--disable-setuid-sandbox', '--disable-features=IsolateOrigins,site-per-process'] 
            )

            if cookies_to_inject:
                log_async("  - å†™å…¥ Cookie åˆ°æŒä¹…åŒ–ä¼šè¯...", is_error=False)
                await context.add_cookies(cookies_to_inject)
            else:
                log_async("  - è·³è¿‡ Cookie å†™å…¥ (åˆ—è¡¨ä¸ºç©º)ã€‚", is_error=False)
                
            await context.close()
            
            log_message = f"âœ… ä¼šè¯æ•°æ®å¤„ç†å®Œæˆã€‚ç›®å½•: '{normalized_dir}'"
            log_async(log_message, is_error=False)
            return (True, "\n".join(final_logs))

    except Exception as e:
        log_async(f"âŒ æ³¨å…¥è¿‡ç¨‹ä¸­å‘ç”Ÿè‡´å‘½é”™è¯¯: {e}", is_error=True)
        log_async("è¯·ç¡®ä¿ Playwright é©±åŠ¨å·²æ­£ç¡®å®‰è£… (playwright install chromium)ã€‚", is_error=True)
        return (False, "\n".join(final_logs))


# --- 3. Tkinter GUI ç•Œé¢ ---

class SessionInjectorApp:
    def __init__(self, master, loop):
        self.master = master
        self.loop = loop 
        master.title("Gemini ä¼šè¯æ³¨å…¥å·¥å…· (å¢å¼ºç‰ˆ)")
        master.geometry("850x950") # å¢åŠ é«˜åº¦ä»¥å®¹çº³æ–°çš„è¾“å…¥æ¡†
        
        self.log_queue = queue.Queue() # æ—¥å¿—é˜Ÿåˆ—
        self.default_base_dir = Path("./")

        # 1. æ ‡é¢˜å’Œè¯´æ˜
        tk.Label(master, text="Gemini ä¼šè¯æ³¨å…¥å·¥å…· (å¢å¼ºç‰ˆ)", font=("Arial", 16, "bold")).pack(pady=10)
        
        tk.Label(master, 
                      text="æ­¥éª¤: 1. F12 æ‰¾åˆ° StreamGenerate è¯·æ±‚; 2. å¤åˆ¶ HAR/JSON/è¯·æ±‚å¤´ç²˜è´´åˆ°ä¸‹æ–¹æˆ–æ‰‹åŠ¨è¾“å…¥ Cookieã€‚", 
                      fg="#333").pack(fill="x", padx=10)
        tk.Label(master, 
                      text="å…³é”® Cookie ä½äº 'Request Headers' çš„ 'Cookie' å­—æ®µï¼ŒåŒ…å« __Secure-1PSIDã€__Secure-3PSID ç­‰ã€‚", 
                      fg="#0056b3", font=("Arial", 10, "italic")).pack(fill="x", padx=10, pady=(0, 5))

        # 2. ç›®å½•é€‰æ‹©åŒºåŸŸ
        dir_frame = ttk.Frame(master)
        dir_frame.pack(fill=tk.X, padx=10, pady=5)
        
        tk.Label(dir_frame, text="ç›®æ ‡ç›®å½•:", anchor="w", font=("Arial", 10, "bold")).pack(side=tk.LEFT, padx=(0, 5))
        self.dir_var = tk.StringVar(value="")
        self.dir_entry = ttk.Entry(dir_frame, textvariable=self.dir_var, width=60)
        self.dir_entry.pack(side=tk.LEFT, expand=True, fill=tk.X)
        self.dir_button = tk.Button(dir_frame, text="é€‰æ‹©ç›®å½•", command=self.select_directory)
        self.dir_button.pack(side=tk.LEFT, padx=(5, 0))
        
        self.auto_dir_button = tk.Button(dir_frame, text="è‡ªåŠ¨åˆ›å»ºæ–°ç›®å½•", command=self.set_auto_new_directory, bg="#2196F3", fg="white")
        self.auto_dir_button.pack(side=tk.LEFT, padx=(5, 0))
        
        # 3. JSON/HAR è¾“å…¥æ¡†
        tk.Label(master, text="ç²˜è´´ StreamGenerate è¯·æ±‚å†…å®¹ (HAR/JSON/æ–‡æœ¬):", anchor="w", font=("Arial", 10, "bold")).pack(fill="x", padx=10, pady=(5, 0))
        self.json_input = scrolledtext.ScrolledText(master, height=10, width=90, wrap=tk.WORD, font=("Consolas", 9))
        self.json_input.pack(pady=5, padx=10)

        # 4. æ‰‹åŠ¨ Cookie è¾“å…¥æ¡† (æ–°å¢)
        tk.Label(master, text="æˆ–ï¼šæ‰‹åŠ¨ç²˜è´´å…³é”® Cookie å­—ç¬¦ä¸²ï¼ˆSID=...;__Secure-1PSID=...ï¼‰:", anchor="w", font=("Arial", 10, "bold")).pack(fill="x", padx=10, pady=(5, 0))
        self.cookie_input = scrolledtext.ScrolledText(master, height=3, width=90, wrap=tk.WORD, font=("Consolas", 9))
        self.cookie_input.pack(pady=5, padx=10)
        
        # 5. æ³¨å…¥æŒ‰é’®å’Œè¿›åº¦æ¡æ¡†æ¶
        btn_frame = ttk.Frame(master)
        btn_frame.pack(fill=tk.X, padx=10, pady=10)
        
        self.inject_button = tk.Button(btn_frame, text="ğŸš€ å¼€å§‹æ³¨å…¥ä¼šè¯", command=self.run_injection, height=2, bg="#4CAF50", fg="white", font=("Arial", 11, "bold"))
        self.inject_button.pack(side=tk.LEFT, expand=True, fill=tk.X)
        
        # è¿›åº¦æ¡
        self.progress = ttk.Progressbar(btn_frame, orient='horizontal', length=200, mode='indeterminate')
        self.progress.pack(side=tk.RIGHT, padx=10)

        # 6. ç»“æœ/æ—¥å¿—è¾“å‡ºæ¡†
        tk.Label(master, text="è¿è¡Œæ—¥å¿—:", anchor="w", font=("Arial", 10, "bold")).pack(fill="x", padx=10)
        self.log_output = scrolledtext.ScrolledText(master, height=15, width=90, state=tk.DISABLED, wrap=tk.WORD, bg="#1e1e1e", fg="#d4d4d4", font=("Consolas", 9))
        self.log_output.pack(pady=5, padx=10, expand=True, fill=tk.BOTH)
        
        # é…ç½®æ—¥å¿—é¢œè‰²æ ‡ç­¾
        self.log_output.tag_config('error', foreground='#ff6b6b')
        self.log_output.tag_config('warn', foreground='#feca57')
        self.log_output.tag_config('success', foreground='#1dd1a1')
        self.log_output.tag_config('normal', foreground='#d4d4d4')
        
        # å¯åŠ¨æ—¥å¿—è½®è¯¢å™¨
        master.after(100, self.poll_log_queue)
        
        if not PLAYWRIGHT_INSTALLED:
             self.log("âš ï¸ è­¦å‘Š: Playwright ä¾èµ–å¯èƒ½ç¼ºå¤±ã€‚è¯·è¿è¡Œ 'pip install playwright' å’Œ 'playwright install chromium'ã€‚", is_warning=True)

    def select_directory(self):
        """æ‰“å¼€å¯¹è¯æ¡†è®©ç”¨æˆ·é€‰æ‹©ç›®æ ‡ç›®å½•"""
        initial_dir = self.dir_var.get() or str(self.default_base_dir)
        directory = filedialog.askdirectory(initialdir=initial_dir, title="é€‰æ‹© Playwright ç”¨æˆ·æ•°æ®ç›®å½•")
        if directory:
            self.dir_var.set(directory)
            self.log(f"ğŸ“ ç›®æ ‡ç›®å½•å·²è®¾ç½®ä¸º: {directory}", is_warning=True)
        
    def set_auto_new_directory(self):
        """è‡ªåŠ¨æ£€æµ‹å¹¶è®¾ç½®ä¸‹ä¸€ä¸ªå¯ç”¨çš„æ–°ç›®å½•"""
        try:
            new_dir = get_next_available_dir(self.default_base_dir)
            self.dir_var.set(new_dir)
            self.log(f"ğŸ“ å·²è‡ªåŠ¨é€‰æ‹©æ–°ç›®å½•: {new_dir}", is_warning=False)
        except RuntimeError as e:
            self.log(f"âŒ è‡ªåŠ¨åˆ›å»ºç›®å½•å¤±è´¥: {e}", is_error=True)
            messagebox.showerror("é”™è¯¯", str(e))


    def log(self, message, is_error=False, is_warning=False, is_success=False):
        """å°†ä¿¡æ¯å®‰å…¨åœ°æ‰“å°åˆ° GUI æ—¥å¿—åŒºåŸŸï¼Œå¹¶å¼ºåˆ¶åˆ·æ–°ã€‚"""
        self.log_output.config(state=tk.NORMAL)
        
        tag = "normal"
        if is_error or "âŒ" in message: tag = "error"
        elif is_warning or "âš ï¸" in message: tag = "warn"
        elif is_success or "æˆåŠŸ" in message or "âœ…" in message or "âœ¨" in message: tag = "success"
            
        self.log_output.insert(tk.END, message + "\n", tag)
        self.log_output.see(tk.END)
        self.log_output.config(state=tk.DISABLED)
        self.master.update_idletasks()


    def poll_log_queue(self):
        """Tkinter ä¸»çº¿ç¨‹å®šæœŸæ£€æŸ¥æ—¥å¿—é˜Ÿåˆ—å¹¶å®‰å…¨æ›´æ–° GUIã€‚"""
        while not self.log_queue.empty():
            message, is_error = self.log_queue.get()
            is_warn = "è­¦å‘Š" in message or "âš ï¸" in message
            self.log(message, is_error=is_error, is_warning=is_warn)
        
        self.master.after(100, self.poll_log_queue)


    def run_injection(self):
        """å¤„ç†æŒ‰é’®ç‚¹å‡»äº‹ä»¶ï¼Œå¯åŠ¨å¼‚æ­¥ä»»åŠ¡ï¼ˆéé˜»å¡ï¼‰"""
        self.log_output.config(state=tk.NORMAL)
        self.log_output.delete(1.0, tk.END)
        self.log_output.config(state=tk.DISABLED)
        
        raw_text = self.json_input.get(1.0, tk.END).strip()
        manual_cookie_text = self.cookie_input.get(1.0, tk.END).strip()
        target_dir = self.dir_var.get().strip()

        if not raw_text and not manual_cookie_text:
            self.log("âŒ è¯·å…ˆç²˜è´´è¯·æ±‚å†…å®¹æˆ–æ‰‹åŠ¨è¾“å…¥ Cookieï¼", is_error=True)
            return

        if not target_dir:
            try:
                target_dir = get_next_available_dir(self.default_base_dir)
                self.dir_var.set(target_dir)
                self.log(f"ğŸ“ æœªæŒ‡å®šç›®å½•ï¼Œè‡ªåŠ¨åˆ›å»ºåˆ°: {target_dir}", is_warning=True)
            except RuntimeError as e:
                self.log(f"âŒ ç›®å½•é”™è¯¯: {e}", is_error=True)
                return

        self.inject_button.config(state=tk.DISABLED, text="â³ å¤„ç†ä¸­...")
        self.progress.start()
        
        # å¯åŠ¨å¼‚æ­¥ä»»åŠ¡
        task = self.loop.create_task(self.full_injection_task(raw_text, manual_cookie_text, target_dir))
        task.add_done_callback(self.on_injection_done)
        
    async def full_injection_task(self, raw_text: str, manual_cookie_text: str, target_dir: str) -> Tuple[bool, str]:
        """å¼‚æ­¥ä»»åŠ¡åè°ƒå™¨"""
        
        def log_safe(message, is_error=False):
            self.log_queue.put((message, is_error))

        # --- 1. è§£æ ---
        log_safe("ğŸ” [1/2] æ­£åœ¨è§£æå†…å®¹...", is_error=False)
        
        # ä½¿ç”¨ run_in_executor åœ¨å•ç‹¬çš„çº¿ç¨‹ä¸­è¿è¡ŒåŒæ­¥è§£æå‡½æ•°
        future = self.loop.run_in_executor(
            None, 
            _sync_parse_and_validate,
            raw_text
        )
        
        try:
            success, session_data_inner, logs = await future
            log_safe(logs)
        except Exception as e:
            log_safe(f"âŒ è§£æçº¿ç¨‹å¼‚å¸¸: {e}", is_error=True)
            return (False, "è§£æçº¿ç¨‹å¤±è´¥ã€‚")

        # --- 1.1 Cookie è¡¥å……/è¦†ç›–é€»è¾‘ (æ–°å¢) ---
        if success:
            extracted_cookies = session_data_inner.get('cookies', {})
            
            if manual_cookie_text:
                manual_cookies = parse_cookies_from_string(manual_cookie_text)
                if manual_cookies:
                    log_safe(f"ğŸ”— [è¡¥å……] å‘ç°æ‰‹åŠ¨è¾“å…¥çš„ {len(manual_cookies)} ä¸ªå…³é”® Cookieã€‚")
                    # ä½¿ç”¨æ‰‹åŠ¨ Cookie è¦†ç›–å’Œè¡¥å……è‡ªåŠ¨è§£æçš„ç»“æœ
                    extracted_cookies.update(manual_cookies)
                else:
                    log_safe("âš ï¸ [è­¦å‘Š] æ— æ³•è§£ææ‰‹åŠ¨è¾“å…¥çš„ Cookieï¼Œè¯·æ£€æŸ¥æ ¼å¼ã€‚", is_error=True)

            
            # æœ€ç»ˆæ£€æŸ¥ Cookie
            if not extracted_cookies and session_data_inner.get('dynamicParams'):
                 # å¦‚æœåŠ¨æ€å‚æ•°æå–æˆåŠŸï¼Œä½† Cookie ä»ç„¶ä¸ºç©ºï¼Œåˆ™åˆ¤å®šä¸º Cookie ç¼ºå¤±
                 log_safe("âŒ [è‡´å‘½] æå–åˆ°åŠ¨æ€å‚æ•°ï¼Œä½†æœ€ç»ˆ Cookie ä»ä¸ºç©ºã€‚æ³¨å…¥å°†å¤±è´¥ã€‚", is_error=True)
                 return (False, "Cookie ç¼ºå¤±ã€‚")

            session_data_inner['cookies'] = extracted_cookies
            
        elif manual_cookie_text:
             # å¦‚æœè‡ªåŠ¨è§£æå¤±è´¥ï¼Œä½†ç”¨æˆ·æä¾›äº†æ‰‹åŠ¨ Cookieï¼Œæˆ‘ä»¬å°è¯•ä» Cookie ä¸­æå– fSid/at
             # ä½†ç”±äº fSid/at æ— æ³•ä» Cookie ä¸­æå–ï¼Œè¿™é‡Œåªèƒ½è¦æ±‚ç”¨æˆ·ç¡®ä¿ä¸»è¾“å…¥æ¡†åŒ…å«åŠ¨æ€å‚æ•°
             log_safe("âš ï¸ [è­¦å‘Š] è‡ªåŠ¨è§£æå¤±è´¥ï¼Œä½†å‘ç°æ‰‹åŠ¨ Cookieã€‚è¯·ç¡®ä¿ä¸»è¾“å…¥æ¡†åŒ…å« URL å’Œ POST å‚æ•°ä»¥ä¾¿æå– fSid å’Œ atã€‚", is_error=True)
             return (False, "è‡ªåŠ¨è§£æå¤±è´¥ä¸”æ— æ³•æå–åŠ¨æ€å‚æ•°ã€‚")
        else:
             # è‡ªåŠ¨è§£æå¤±è´¥ä¸”æ²¡æœ‰æ‰‹åŠ¨ Cookie è¡¥å……
             return (False, "è§£æå¤±è´¥ã€‚")

        # --- 2. æ³¨å…¥ ---
        full_session_data = {
            "data": session_data_inner,
            "cookieDomain": ".google.com",
            "cookiePath": "/"
        }
        
        log_safe(f"ğŸ”¨ [2/2] å¯åŠ¨ Playwright æ³¨å…¥ -> {target_dir}", is_error=False)
        
        return await inject_cookies_to_context(target_dir, full_session_data, self.log_queue)
            

    def on_injection_done(self, task):
        """å›è°ƒå‡½æ•°ï¼Œå¤„ç†ä»»åŠ¡ç»“æœå¹¶æ›´æ–° GUI"""
        self.inject_button.config(state=tk.NORMAL, text="ğŸš€ å¼€å§‹æ³¨å…¥ä¼šè¯")
        self.progress.stop()
        
        try:
            success, full_logs = task.result()
            
            # å°è¯•ä»æ—¥å¿—ä¸­æå–ç›®å½•å
            match = re.search(r"ç›®å½•: '(.*?)'", full_logs)
            target_dir = match.group(1) if match else self.dir_var.get()
            
            # æ¸…ç†è·¯å¾„ä»¥è·å–ç´¢å¼•
            dir_name = Path(target_dir).name
            dir_index = dir_name.split('_')[-1] if 'user_data_' in dir_name else "?"
            
            if success:
                self.log_queue.put(("\n" + "=" * 60, False))
                self.log_queue.put(("âœ¨ æ³¨å…¥æµç¨‹ç»“æŸã€‚è¯·æ£€æŸ¥ä¸Šæ–¹æ˜¯å¦æœ‰è­¦å‘Šï¼Œç‰¹åˆ«æ˜¯ Cookie æ•°é‡ã€‚", True))
                self.log_queue.put((f"1. .env é…ç½®: PLAYWRIGHT_USER_DATA_DIR_{dir_index}={target_dir}", False))
                self.log_queue.put((f"2. Docker æŒ‚è½½: - {target_dir}:/app/{target_dir}", False))
                self.log_queue.put(("=" * 60, False))
                messagebox.showinfo("å®Œæˆ", f"å¤„ç†å®Œæˆã€‚\nç›®å½•: {target_dir}\nè¯·æŸ¥çœ‹æ—¥å¿—ç¡®è®¤ Cookie æ˜¯å¦æˆåŠŸå†™å…¥ã€‚")
            else:
                self.log_queue.put((f"\nâŒ æµç¨‹å¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ—¥å¿—ï¼", True))
                messagebox.showerror("å¤±è´¥", "æµç¨‹å¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ—¥å¿—ã€‚")

        except asyncio.CancelledError:
            self.log_queue.put(("âš ï¸ ä»»åŠ¡å–æ¶ˆã€‚", True))
        except Exception as e:
            self.log_queue.put((f"âŒ æœªçŸ¥é”™è¯¯: {e}", True))
            import traceback
            traceback.print_exc()


if __name__ == "__main__":
    # Windows å…¼å®¹æ€§è®¾ç½®
    if sys.platform == "win32":
        try:
            # ç¡®ä¿ Windows ä¸‹ä½¿ç”¨ ProactorEventLoop
            asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())
        except Exception:
            pass

    try:
        loop = asyncio.get_event_loop()
    except RuntimeError:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
    
    root = tk.Tk()
    app = SessionInjectorApp(root, loop)
    
    # å°† asyncio loop é©±åŠ¨åˆ° Tkinter çš„ä¸»å¾ªç¯ä¸­
    def run_asyncio_loop_driver():
        try:
            # è¿è¡Œå·²å‡†å¤‡å¥½çš„ Future/Task
            loop.run_until_complete(asyncio.sleep(0))
        except Exception:
            # æ•è·å¼‚å¸¸ï¼Œé˜²æ­¢ä¸»å¾ªç¯ä¸­æ–­
            pass
        root.after(10, run_asyncio_loop_driver)

    root.after(10, run_asyncio_loop_driver)
    root.mainloop()

--- æ–‡ä»¶è·¯å¾„: main.py ---

import sys
from contextlib import asynccontextmanager
from typing import Optional
import time
import traceback
import httpx 

from fastapi import FastAPI, Request, HTTPException, Depends, Header
from fastapi.responses import JSONResponse, StreamingResponse
from loguru import logger

from app.core.config import settings
from app.providers.gemini_provider import GeminiProvider 

# --- é…ç½® Loguru ---
logger.remove()
logger.add(
    sys.stdout,
    level="INFO",
    format="<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> | <level>{level: <8}</level> | <cyan>{name}:{function}:{line}</cyan> - <level>{message}</level>",
    colorize=True
)

provider: Optional[GeminiProvider] = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    global provider
    logger.info(f"åº”ç”¨å¯åŠ¨ä¸­... {settings.APP_NAME} v{settings.APP_VERSION}")
    provider = GeminiProvider()
    await provider.initialize()
    num_sessions = len(provider.browser_pool)
    logger.info(f"æœåŠ¡å·²åœ¨ 'Headless-Browser-Interaction' æ¨¡å¼ä¸‹åˆå§‹åŒ– {num_sessions} ä¸ªå¯ç”¨æµè§ˆå™¨å®ä¾‹ã€‚")
    if num_sessions == 0:
        logger.error("ğŸš« æµè§ˆå™¨å®ä¾‹å¯åŠ¨å¤±è´¥ï¼è¯·æ£€æŸ¥ Playwright ä¾èµ–å’Œç³»ç»Ÿç¯å¢ƒã€‚")
    logger.info(f"æœåŠ¡å°†åœ¨ http://localhost:{settings.NGINX_PORT} ä¸Šå¯ç”¨")
    yield
    await provider.close()
    logger.info("åº”ç”¨å…³é—­ï¼Œæµè§ˆå™¨å®ä¾‹å·²æ¸…ç†ã€‚")

# Uvicorn æ­£åœ¨å¯»æ‰¾çš„ FastAPI åº”ç”¨å®ä¾‹
app = FastAPI(
    title=settings.APP_NAME,
    version=settings.APP_VERSION,
    description=settings.DESCRIPTION,
    lifespan=lifespan
)

async def verify_api_key(authorization: Optional[str] = Header(None)):
    if settings.API_MASTER_KEY and settings.API_MASTER_KEY != "1":
        if not authorization or "bearer" not in authorization.lower():
            raise HTTPException(status_code=401, detail="éœ€è¦ Bearer Token è®¤è¯ã€‚")
        token = authorization.split(" ")[-1]
        if token != settings.API_MASTER_KEY:
            raise HTTPException(status_code=403, detail="æ— æ•ˆçš„ API Keyã€‚")

@app.post("/v1/chat/completions", dependencies=[Depends(verify_api_key)], response_model=None, response_class=JSONResponse)
async def chat_completions(request: Request):
    if not provider or not provider.browser_pool:
        raise HTTPException(status_code=503, detail="æœåŠ¡ä¸å¯ç”¨ï¼šæµè§ˆå™¨å®ä¾‹æœªå¯åŠ¨æˆ–åˆå§‹åŒ–å¤±è´¥ã€‚")
    try:
        request_data = await request.json()
        return await provider.chat_completion(request_data) 
    except Exception as e:
        logger.error(f"å¤„ç†èŠå¤©è¯·æ±‚æ—¶å‘ç”Ÿé¡¶å±‚é”™è¯¯: {e}", exc_info=False)
        logger.error(f"é¡¶å±‚è°ƒç”¨æ ˆè¿½è¸ª:\n{traceback.format_exc(limit=5)}")
        if isinstance(e, HTTPException):
            raise e
        raise HTTPException(status_code=500, detail=f"å†…éƒ¨æœåŠ¡å™¨é”™è¯¯: {str(e)}")

@app.get("/v1/models", dependencies=[Depends(verify_api_key)])
async def list_models():
    return JSONResponse(content={
        "object": "list", 
        "data": [{"id": name, "object": "model", "created": int(time.time()), "owned_by": "Google"} for name in settings.KNOWN_MODELS]
    })
        
@app.get("/", summary="æ ¹è·¯å¾„", include_in_schema=False)
def root():
    if not provider:
        raise HTTPException(status_code=503, detail="æœåŠ¡åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·æ£€æŸ¥åº”ç”¨æ—¥å¿—ã€‚")
    if not provider.browser_pool:
        raise HTTPException(status_code=503, detail="æœåŠ¡åˆå§‹åŒ–æˆåŠŸï¼Œä½†æµè§ˆå™¨å®ä¾‹æ± ä¸ºç©ºã€‚è¯·æ£€æŸ¥æ—¥å¿—ã€‚")
        
    return {"message": f"æ¬¢è¿æ¥åˆ° {settings.APP_NAME} v{settings.APP_VERSION}. æœåŠ¡è¿è¡Œæ­£å¸¸ã€‚"}

--- æ–‡ä»¶è·¯å¾„: nginx.conf ---

worker_processes auto;

events {
    worker_connections 1024;
}

http {
    upstream gemini_backend {
        # ç”±äº Playwright å®ä¾‹æ˜¯æœ‰çŠ¶æ€çš„ï¼Œå¹¶ä¸”æˆ‘ä»¬ä½¿ç”¨é”æ¥æ§åˆ¶è®¿é—®ï¼Œ
        # è¿™é‡Œä¸éœ€è¦ ip_hashï¼Œç®€å•çš„è½®è¯¢å³å¯ã€‚
        server app:8000;
    }

    server {
        listen 80;
        server_name localhost;

        location / {
            proxy_pass http://gemini_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # æµå¼ä¼ è¾“ä¼˜åŒ–
            proxy_buffering off;
            proxy_cache off;
            proxy_set_header Connection '';
            proxy_http_version 1.1;
            chunked_transfer_encoding off;
        }
    }
}

--- æ–‡ä»¶è·¯å¾„: requirements.txt ---

fastapi
uvicorn[standard]
pydantic-settings
python-dotenv
httpx
loguru
playwright

--- æ–‡ä»¶è·¯å¾„: app\core\__init__.py ---



--- æ–‡ä»¶è·¯å¾„: app\core\config.py ---

import os
import uuid
# ä¿®æ­£è¿™é‡Œçš„å¯¼å…¥ï¼Œç¡®ä¿åªä½¿ç”¨æ­£ç¡®çš„åç§° SettingsConfigDict
from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import List, Optional
from loguru import logger

class Settings(BaseSettings):
    # å…³é”®ä¿®å¤ï¼šä¿®æ­£ç±»åæ‹¼å†™é”™è¯¯
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding='utf-8',
        extra="ignore"
    )

    APP_NAME: str = "gemini-2api"
    APP_VERSION: str = "1.0.0"
    DESCRIPTION: str = "ä¸€ä¸ªå°† gemini.google.com è½¬æ¢ä¸ºå…¼å®¹ OpenAI æ ¼å¼ API çš„é«˜æ€§èƒ½ä»£ç†ï¼Œä½¿ç”¨ Playwright ç»´æŠ¤ä¼šè¯ã€‚"

    API_MASTER_KEY: Optional[str] = None
    NGINX_PORT: int = 8088
    PLAYWRIGHT_POOL_SIZE: int = 3

    API_REQUEST_TIMEOUT: int = 180
    
    API_REQUEST_TIMEOUT: int = 180
    DEFAULT_MODEL: str = "gemini-pro"
    KNOWN_MODELS: List[str] = ["gemini-pro"]

    def __init__(self, **values):
        super().__init__(**values)

settings = Settings()

--- æ–‡ä»¶è·¯å¾„: app\playwright_utils\initial_login.py ---

import asyncio
import sys
import os
from pathlib import Path
from playwright.async_api import async_playwright, TimeoutError
from loguru import logger

# é…ç½®æ—¥å¿—
logger.remove()
logger.add(
    sys.stdout,
    level="INFO",
    format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <level>{message}</level>",
    colorize=True
)

async def main(user_data_dir: str):
    """
    å¯åŠ¨ä¸€ä¸ªå¸¦ç•Œé¢çš„æµè§ˆå™¨ï¼Œç”¨äºç”¨æˆ·æ‰‹åŠ¨ç™»å½•Googleè´¦æˆ·ã€‚
    ç™»å½•ä¿¡æ¯å°†ä¿å­˜åœ¨æŒ‡å®šçš„ user_data_dir ä¸­ã€‚
    """
    logger.info("--- é¦–æ¬¡ç™»å½•åŠ©æ‰‹ ---")
    logger.info(f"å°†ä¸º '{user_data_dir}' ç›®å½•å¯åŠ¨ä¸€ä¸ªæ–°çš„æµè§ˆå™¨å®ä¾‹...")
    logger.info("è¯·åœ¨å¼¹å‡ºçš„æµè§ˆå™¨çª—å£ä¸­å®Œæˆä»¥ä¸‹æ“ä½œ:")
    logger.info("1. ç™»å½•æ‚¨çš„ Google è´¦æˆ·ã€‚")
    logger.info("2. ç¡®ä¿æ‚¨å·²åœ¨ Gemini é¡µé¢ã€‚")
    logger.info("3. ç™»å½•æˆåŠŸåï¼Œè¯·æ‰‹åŠ¨å…³é—­æ•´ä¸ªæµè§ˆå™¨çª—å£ã€‚")
    logger.info("è„šæœ¬å°†åœ¨æ­¤ä¹‹åè‡ªåŠ¨ç»“æŸï¼Œæ‚¨çš„ä¼šè¯å°†è¢«æˆåŠŸä¿å­˜å¹¶æˆªå›¾ã€‚")
    logger.info("-" * 40)
    
    # æˆªå›¾ä¿å­˜è·¯å¾„ (ç›¸å¯¹äºé¡¹ç›®æ ¹ç›®å½•)
    screenshot_dir = Path("debug")
    screenshot_dir.mkdir(exist_ok=True)
    session_name = Path(user_data_dir).name
    screenshot_path = screenshot_dir / f"{session_name}_login_success.png"
    
    try:
        async with async_playwright() as p:
            # å¯åŠ¨ä¸€ä¸ªæŒä¹…åŒ–çš„ä¸Šä¸‹æ–‡
            browser_context = await p.chromium.launch_persistent_context(
                user_data_dir,
                headless=False,  # å¿…é¡»ä¸º False æ‰èƒ½æ˜¾ç¤ºç•Œé¢è®©ç”¨æˆ·æ“ä½œ
                user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36",
                # åœ¨ Docker ç¯å¢ƒä¸­è¿è¡Œæ—¶å¢åŠ ç¨³å®šæ€§ï¼Œæ³¨æ„ï¼šåœ¨ Docker ä¸­å¯ç”¨é Headless å¯èƒ½éœ€è¦é¢å¤–çš„ X server é…ç½®
                args=['--no-sandbox', '--disable-setuid-sandbox'] 
            )
            
            page = await browser_context.new_page()
            await page.goto("https://gemini.google.com", timeout=90000)
            
            logger.info("æµè§ˆå™¨å·²æ‰“å¼€ï¼Œæ­£åœ¨ç­‰å¾…æ‚¨ç™»å½•å¹¶å…³é—­çª—å£...")
            
            try:
                # ç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨å…³é—­æµè§ˆå™¨ï¼Œè¿™æ˜¯ä¸€ä¸ªé˜»å¡æ“ä½œ
                await browser_context.wait_for_event("close", timeout=300000)
            except TimeoutError:
                logger.warning("ç­‰å¾…è¶…æ—¶ (5åˆ†é’Ÿ)ã€‚è¯·æ‰‹åŠ¨æ£€æŸ¥æµè§ˆå™¨çŠ¶æ€ã€‚")
            
            logger.info("æµè§ˆå™¨å·²å…³é—­ã€‚å°è¯•éªŒè¯ä¼šè¯å¹¶æˆªå›¾...")
            
            # --- æˆªå›¾é€»è¾‘ ---
            # é‡å¯ä¸€ä¸ª HEADLESS å®ä¾‹æ¥å®‰å…¨æˆªå›¾ï¼Œé˜²æ­¢ç”¨æˆ·åœ¨éæ— å¤´æ¨¡å¼ä¸‹é¡µé¢çŠ¶æ€ä¸ç¨³
            temp_context = await p.chromium.launch_persistent_context(
                user_data_dir,
                headless=True, 
                args=['--no-sandbox', '--disable-setuid-sandbox']
            )
            temp_page = await temp_context.new_page()
            await temp_page.goto("https://gemini.google.com/app", timeout=30000)
            await temp_page.wait_for_load_state('networkidle')

            # æ£€æŸ¥æ˜¯å¦æˆåŠŸç™»å½•ï¼ˆé€šå¸¸æ˜¯é€šè¿‡æ£€æŸ¥æ˜¯å¦æœ‰ç™»å½•æŒ‰é’®æˆ–ç‰¹å®šçš„å…ƒç´ ï¼‰
            title = await temp_page.title()
            if "Gemini" in title and "Sign in" not in title:
                await temp_page.screenshot(path=screenshot_path)
                logger.success(f"âœ… ç™»å½•ä¼šè¯æˆåŠŸä¿å­˜ï¼æˆªå›¾å·²ä¿å­˜åˆ°: {screenshot_path}")
            else:
                 logger.error("âŒ è­¦å‘Š: æˆªå›¾æ˜¾ç¤ºå¯èƒ½æœªæˆåŠŸç™»å½•ã€‚è¯·é‡æ–°å°è¯•ã€‚")

            await temp_context.close()
            
            logger.success(f"\nä¼šè¯å·²ä¿å­˜åˆ° '{user_data_dir}'ã€‚æ‚¨ç°åœ¨å¯ä»¥æ­£å¸¸å¯åŠ¨ gemini-2api æœåŠ¡äº†ã€‚")

    except Exception as e:
        logger.error(f"å¯åŠ¨æµè§ˆå™¨æˆ–ç™»å½•è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: {e}")
        logger.error("è¯·ç¡®ä¿æ‚¨çš„ç¯å¢ƒä¸­å·²æ­£ç¡®å®‰è£… Playwright é©±åŠ¨ ('playwright install chromium')ã€‚")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("ç”¨æ³•: python playwright_utils/initial_login.py <path_to_user_data_dir>")
        print("ç¤ºä¾‹: python playwright_utils/initial_login.py ./user_data_1")
        sys.exit(1)
    
    data_dir = sys.argv[1]
    # åœ¨ Windows ä¸Šè¿è¡Œï¼Œéœ€è¦ç‰¹å®šçš„äº‹ä»¶å¾ªç¯ç­–ç•¥
    if sys.platform == "win32":
        try:
            asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())
        except Exception:
            pass
    
    asyncio.run(main(data_dir))

--- æ–‡ä»¶è·¯å¾„: app\providers\__init__.py ---



--- æ–‡ä»¶è·¯å¾„: app\providers\base_provider.py ---

from abc import ABC, abstractmethod
from typing import Dict, Any
from fastapi.responses import StreamingResponse, JSONResponse

class BaseProvider(ABC):
    @abstractmethod
    async def chat_completion(self, request_data: Dict[str, Any]) -> StreamingResponse:
        pass

    @abstractmethod
    async def get_models(self) -> JSONResponse:
        pass

--- æ–‡ä»¶è·¯å¾„: app\providers\gemini_provider.py ---

import json
import time
import asyncio
import random
import re
from typing import Dict, Any, AsyncGenerator, List, Optional, Tuple
from pathlib import Path
from urllib.parse import parse_qs, urlparse, unquote_plus
import traceback
import httpx# ä¿æŒå¯¼å…¥ï¼Œç”¨äºå®¢æˆ·ç«¯åˆå§‹åŒ–

from fastapi import HTTPException
from fastapi.responses import JSONResponse, StreamingResponse
from loguru import logger
from playwright.async_api import async_playwright, Playwright, BrowserContext, Browser, Error as PlaywrightError, Route 

# å¯¼å…¥ BaseProvider
from app.core.config import settings
from app.providers.base_provider import BaseProvider
from app.utils.sse_utils import create_sse_data, create_chat_completion_chunk, DONE_CHUNK

# è°ƒè¯•ç›®å½•å¸¸é‡
DEBUG_DIR = Path("debug")
DEBUG_DIR.mkdir(exist_ok=True)

class BrowserInstance:
    """å°è£… Playwright Browserå®ä¾‹åŠå…¶é”"""
    def __init__(self, browser: Browser, name: str):
        self.browser = browser
        self.lock = asyncio.Lock()
        self.name = name

class GeminiProvider(BaseProvider):
    def __init__(self):
        self.playwright: Optional[Playwright] = None
        self.browser_pool: List[BrowserInstance] = [] # æµè§ˆå™¨å®ä¾‹æ± 
        self.client = httpx.AsyncClient(timeout=settings.API_REQUEST_TIMEOUT)

    async def initialize(self):
        """åˆå§‹åŒ– Playwright å’Œæµè§ˆå™¨å®ä¾‹æ± """
        self.playwright = await async_playwright().start()
        
        logger.info("æ³¨æ„: é‡‡ç”¨ Playwright æå– + ä¼ªæµå¼è¿”å›æ–¹æ¡ˆã€‚")

        for i in range(settings.PLAYWRIGHT_POOL_SIZE):
            session_name = f"Browser-Instance-{i+1}"
            try:
                # å¯åŠ¨ä¸€ä¸ªå¸¸é©»çš„ Browser å®ä¾‹
                browser = await self.playwright.chromium.launch(
                    headless=True,
                    args=[
                        '--no-sandbox', 
                        '--disable-setuid-sandbox', 
                        '--disable-features=IsolateOrigins,site-per-process',
                        '--disable-blink-features=AutomationControlled'
                    ],
                )
                self.browser_pool.append(BrowserInstance(browser, session_name))
                logger.success(f"âœ… {session_name} æµè§ˆå™¨å®ä¾‹å·²æˆåŠŸåŠ è½½ã€‚")

            except PlaywrightError as e:
                logger.error(f"âŒ Playwright åˆå§‹åŒ– {session_name} å¤±è´¥: {e}")
            except Exception as e:
                logger.error(f"âŒ åˆå§‹åŒ– {session_name} å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}")

        if not self.browser_pool:
            logger.error("ğŸš« æ‰€æœ‰æµè§ˆå™¨å®ä¾‹åˆå§‹åŒ–å¤±è´¥ã€‚æœåŠ¡å°†æ— æ³•å·¥ä½œã€‚")
        else:
            logger.success(f"âœ… {len(self.browser_pool)} ä¸ªæµè§ˆå™¨å®ä¾‹å·²æˆåŠŸåŠ è½½ï¼ˆçº¯åŒ¿åéæŒä¹…åŒ–æ¨¡å¼å¯åŠ¨ï¼‰ã€‚")

    async def close(self):
        """æ¸…ç†èµ„æº"""
        for instance in self.browser_pool:
            await instance.browser.close()  
        if self.playwright:
            await self.playwright.stop()
        await self.client.aclose()
    
    # è¾…åŠ©å‡½æ•°ï¼šæå–ç”¨æˆ·çš„æœ€æ–°è¯·æ±‚
    def _get_latest_user_message(self, request_data: Dict[str, Any]) -> str:
        messages = request_data.get("messages", [])
        for m in reversed(messages):
            if m.get('role') == 'user':
                return m.get('content') or "Hello" # ç¡®ä¿ä¸ä¸ºç©º
        return "Hello" # é»˜è®¤å€¼


    async def _get_and_extract_answer(self, instance: BrowserInstance, latest_user_message: str) -> Tuple[str, 'page', 'context']:
        """
        æ ¸å¿ƒæ–¹æ³•ï¼šæ¨¡æ‹Ÿäº¤äº’ï¼Œè®©æµè§ˆå™¨ç”Ÿæˆç­”æ¡ˆï¼Œå¹¶ä» DOM ä¸­æå–æœ€ç»ˆçš„å®Œæ•´å›ç­”ã€‚
        è¿™ä¸ªå‡½æ•°åŒ…å«äº†å‚æ•°æå–ã€ç­‰å¾…ç­”æ¡ˆå®Œæˆå’Œæœ€ç»ˆç­”æ¡ˆæå–çš„æ‰€æœ‰é€»è¾‘ã€‚
        
        :return: (extracted_answer_text, page, context)
        """
        session_name = instance.name
        video_output_dir = DEBUG_DIR.as_posix()
        
        context: BrowserContext = await instance.browser.new_context(
            user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36",
            viewport={"width": 1920, "height": 1080},
            locale="zh-CN",
            record_video_dir=video_output_dir,
            record_video_size={"width": 1280, "height": 720}
        )
        
        page = await context.new_page()
        
        # ---------------------
        # æ­¥éª¤ 0: è®¾ç½®ç½‘ç»œæ‹¦æˆªå™¨ (è®©è¯·æ±‚é€šè¿‡ï¼Œä¸å†æå–å‚æ•°)
        # ---------------------
        
        # æ­¤æ—¶æˆ‘ä»¬ä¸å…³å¿ƒå‚æ•°ï¼Œåªå…³å¿ƒè¯·æ±‚èƒ½æ­£å¸¸å‘å‡ºå’Œå®Œæˆ
        await page.route("**/*", lambda route: route.continue_())

        # ---------------------
        # æ­¥éª¤ 1/4: å¯¼èˆªå’Œæ¨¡æ‹Ÿäº¤äº’
        # ---------------------
        
        try:
            TIMEOUT_USER_ACTION = 10000 
            
            logger.info(f"  - ä¼šè¯ {session_name}: [æ­¥éª¤1] å¯¼èˆªåˆ° Gemini é¦–é¡µ...")
            await page.goto("https://gemini.google.com/app", timeout=30000)
                
            TEXT_INPUT_SELECTOR = 'rich-textarea div.ql-editor'
            SEND_BUTTON_SELECTOR = 'button[aria-label*="Send"], button.send-button' 
            ACTIVE_SEND_BUTTON_SELECTOR = 'button[aria-label*="Send"]:not([aria-disabled="true"]), button.send-button:not([aria-disabled="true"])'
            
            # ç¡®ä¿è¾“å…¥æ¡†å¯è§
            await page.wait_for_selector(TEXT_INPUT_SELECTOR, timeout=TIMEOUT_USER_ACTION)
            
            # 1. **å…³é”®æ­¥éª¤ï¼šè¾“å…¥é€—å· (,) æ¿€æ´»æŒ‰é’®**
            logger.info("    -> å¡«å……é€—å· (,) æ¿€æ´»å‘é€æŒ‰é’®...")
            await page.type(TEXT_INPUT_SELECTOR, ",", delay=50) 
            
            # 2. **å¡«å……ç”¨æˆ·çš„å®Œæ•´è¯·æ±‚**
            full_input = f"{latest_user_message}"
            logger.info(f"    -> å¡«å……ç”¨æˆ·æ¶ˆæ¯: {full_input[:50]}...")
            await page.fill(TEXT_INPUT_SELECTOR, full_input, timeout=5000)
            
            # 3. **ç‚¹å‡»å‘é€**
            logger.info("    -> ç‚¹å‡»å‘é€æŒ‰é’®ï¼Œç­‰å¾…å›ç­”ç”Ÿæˆ...")
            
            # è§¦å‘è¯·æ±‚ï¼Œå¹¶ç­‰å¾…æµè§ˆå™¨å®Œæˆç­”æ¡ˆç”Ÿæˆ
            # è¿™é‡Œæˆ‘ä»¬åªç­‰å¾…ä¸€ä¸ªç½‘ç»œå“åº”å®Œæˆï¼Œè¡¨ç¤ºå¼€å§‹ç”Ÿæˆç­”æ¡ˆã€‚
            await page.click(ACTIVE_SEND_BUTTON_SELECTOR, timeout=3000)
            
            
            # ---------------------
            # æ­¥éª¤ 5: ç­‰å¾…ç­”æ¡ˆå®Œæˆå¹¶æå–æ–‡æœ¬
            # ---------------------
            
            # ç­‰å¾…å‘é€æŒ‰é’®é‡æ–°ç¦ç”¨ (è¡¨ç¤ºå›ç­”ç»“æŸ)
            ANSWER_FINISHED_SELECTOR = SEND_BUTTON_SELECTOR + '[aria-disabled="true"]'
            
            try:
                # ç­‰å¾…æŒ‰é’®å˜ç¦ç”¨
                await page.wait_for_selector(ANSWER_FINISHED_SELECTOR, timeout=40000) # å»¶é•¿è¶…æ—¶ä»¥é€‚åº”é•¿å›ç­”
                logger.success("    -> ç­”æ¡ˆç”Ÿæˆå®Œæ¯• (å‘é€æŒ‰é’®é‡æ–°ç¦ç”¨)ã€‚")

            except PlaywrightError as e:
                logger.warning(f"    -> ç­”æ¡ˆç­‰å¾…è¶…æ—¶ï¼Œå°è¯•æå–å½“å‰å¯è§ç­”æ¡ˆã€‚é”™è¯¯: {e}")
            
            # æå–æœ€ç»ˆç­”æ¡ˆæ–‡æœ¬
            ANSWER_CONTENT_SELECTOR = 'message-content' 
            
            extracted_answer = "Error: Failed to extract response text."
            try:
                answer_locator = page.locator(ANSWER_CONTENT_SELECTOR)
                last_answer_block = answer_locator.last
                
                # ä½¿ç”¨ inner_text() è·å–æ¸²æŸ“åçš„æ–‡æœ¬ï¼ˆåŒ…æ‹¬ Markdown æ ‡è®°ï¼‰
                extracted_answer = await last_answer_block.inner_text() 
                
            except Exception as e:
                logger.error(f"æå–ç­”æ¡ˆæ–‡æœ¬å¤±è´¥: {e}")
                
            
            
            # --- æœ€ç»ˆæ£€æŸ¥å’Œè¿”å› ---
            
            if not extracted_answer or extracted_answer.startswith("Error:"):
                 # å¦‚æœæå–å¤±è´¥ï¼Œå°è¯•è·å– body çš„æ–‡æœ¬ï¼Œä½œä¸ºæœ€åçš„è°ƒè¯•æ‰‹æ®µ
                 last_resort_text = await page.content()
                 logger.error(f"âŒ Playwright æå–å¤±è´¥ã€‚HTML å†…å®¹ç‰‡æ®µ: {last_resort_text[:500]}...")
                 raise RuntimeError(f"Playwright æå–å¤±è´¥ã€‚æå–ç»“æœ: {extracted_answer}")

            logger.success(f"ğŸ”‘ ä¼šè¯ {session_name} ç­”æ¡ˆæå–æˆåŠŸã€‚")
            
            # è¿”å›æå–åˆ°çš„æ–‡æœ¬å’Œèµ„æºï¼Œä»¥ä¾¿åœ¨ chat_completion ä¸­å¤„ç†æ¸…ç†
            return extracted_answer, page, context
            
        except Exception as e:
            logger.error(f"âŒ Playwright æ¨¡æ‹Ÿäº¤äº’/æå–è¿‡ç¨‹ä¸­å‘ç”Ÿä¸¥é‡é”™è¯¯: {e}")
            
            try:
                await context.close()
            except:
                pass
            raise e

    # -----------------------------------------------
    # ä¼ªæµå¼ç”Ÿæˆå™¨ (ç”¨äºæ¨¡æ‹Ÿæµå¼ä½“éªŒ)
    # -----------------------------------------------
    async def _pseudo_stream_generator(self, extracted_text: str, request_id: str, model_name: str) -> AsyncGenerator[bytes, None]:
        
        # å°†ç­”æ¡ˆæ–‡æœ¬åˆ†æˆå°å—ï¼Œæ¨¡æ‹Ÿæµå¼æ•ˆæœ
        # ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æŒ‰ç©ºæ ¼æˆ–æ ‡ç‚¹ç¬¦å·åˆ†å‰²ï¼Œä¿ç•™ Markdown æ ¼å¼
        chunks = re.findall(r'(\*\*.*?\*\*|\n\n|\s|[^ \n]+)', extracted_text, re.DOTALL)
        
        if not chunks:
            chunks = [extracted_text] # å¦‚æœæ— æ³•åˆ†å‰²ï¼Œå‘é€æ•´ä¸ªæ–‡æœ¬

        for chunk in chunks:
            if chunk:
                # å…¼å®¹Markdownï¼Œä½†ä¸è½¬ä¹‰
                yield create_sse_data(create_chat_completion_chunk(request_id, model_name, chunk))
                # å¼•å…¥å¾®å°å»¶è¿Ÿæ¥æ¨¡æ‹Ÿæµå¼ä¼ è¾“æ„Ÿ
                await asyncio.sleep(0.01) 
        
        # å‘é€ç»“æŸæ ‡è®°
        yield DONE_CHUNK


    def _create_openai_json_response(self, text_content: str) -> Dict[str, Any]:
        """å°†æå–çš„å®Œæ•´ç­”æ¡ˆå°è£…æˆéæµå¼çš„ OpenAI JSON æ ¼å¼ã€‚"""
        # ä¿æŒåŸå§‹ Markdown æ ¼å¼
        cleaned_text = text_content.strip() 
        
        logger.info(f"ğŸ“ æœ€ç»ˆè¿”å›å†…å®¹ (é•¿åº¦: {len(cleaned_text)}): {cleaned_text[:200]}...")

        return {
            "id": f"chatcmpl-{int(time.time())}",
            "object": "chat.completion",
            "created": int(time.time()),
            "model": settings.DEFAULT_MODEL,
            "choices": [
                {
                    "index": 0,
                    "message": {
                        "role": "assistant",
                        "content": cleaned_text
                    },
                    "finish_reason": "stop"
                }
            ],
            "usage": {
                "prompt_tokens": 0,
                "completion_tokens": 0,
                "total_tokens": 0
            }
        }


    async def chat_completion(self, request_data: Dict[str, Any]) -> [JSONResponse, StreamingResponse]:
        """
        å¤„ç†èŠå¤©è¯·æ±‚ï¼Œè¿”å›ä¼ªæµå¼ StreamingResponse æˆ–éæµå¼ JSONResponseã€‚
        """
        if not self.browser_pool:
            raise HTTPException(status_code=503, detail="æœåŠ¡ä¸å¯ç”¨ï¼šæµè§ˆå™¨å®ä¾‹æ± ä¸ºç©ºã€‚")
        
        is_streaming_request = request_data.get("stream") is True
        latest_user_message = self._get_latest_user_message(request_data)
        instance = random.choice(self.browser_pool)
        
        page = None
        context = None
        
        # é”ä½å®ä¾‹ï¼Œæ‰§è¡Œäº¤äº’å’Œæå–
        async with instance.lock:
            try:
                # è¿è¡Œ Playwright äº¤äº’å¹¶æå–å®Œæ•´ç­”æ¡ˆ
                extracted_text, page, context = await self._get_and_extract_answer(instance, latest_user_message)
            except Exception as e:
                error_msg = f"æ— æ³•ä»æµè§ˆå™¨è·å–å®Œæ•´ç­”æ¡ˆã€‚é”™è¯¯: {e}"
                logger.error(f"ä¼šè¯ {instance.name} å¤±è´¥: {e}")
                raise HTTPException(status_code=502, detail=error_msg)
        
        # --- Playwright æå–æˆåŠŸï¼Œå¤„ç†æ¸…ç†å’Œå½•å± ---
        
        video_output_dir = DEBUG_DIR.as_posix()

        async def cleanup_and_save_video(p, c):
            """åœ¨åå°ä»»åŠ¡ä¸­ä¿å­˜å½•å±å¹¶å…³é—­ Playwright èµ„æº"""
            try:
                video = p.video
                video_filename = Path(await video.path()).name 
                final_video_path = Path(video_output_dir) / video_filename
                
                Path(final_video_path).parent.mkdir(parents=True, exist_ok=True)
                await video.save_as(final_video_path)
                logger.info(f"ğŸ¥ å½•å±å·²ä¿å­˜åˆ°: {final_video_path.as_posix()}")
            except Exception as e:
                logger.warning(f"æ— æ³•ä¿å­˜å½•å±: {e}")
            finally:
                if c: await c.close()
        
        # åˆ›å»ºå¼‚æ­¥ä»»åŠ¡æ¥å¤„ç†å½•å±å’Œæ¸…ç†ï¼Œç¡®ä¿ä¸»çº¿ç¨‹ä¸é˜»å¡
        asyncio.create_task(cleanup_and_save_video(page, context))
        
        # -----------------------------------------
        # è¿”å›å“åº” (ä¼ªæµå¼æˆ–éæµå¼)
        # -----------------------------------------
        
        if is_streaming_request:
            # å®¢æˆ·ç«¯è¯·æ±‚æµå¼ï¼Œè¿”å›ä¼ªæµå¼ StreamingResponse
            logger.info("ğŸŸ¢ å®¢æˆ·ç«¯è¯·æ±‚æµå¼å“åº”ï¼Œè¿”å›ä¼ªæµå¼ StreamingResponseã€‚")
            return StreamingResponse(
                self._pseudo_stream_generator(extracted_text, "chatcmpl-pseudo", settings.DEFAULT_MODEL),
                media_type="text/event-stream"
            )

        else:
            # å®¢æˆ·ç«¯è¯·æ±‚éæµå¼ï¼Œè¿”å›å®Œæ•´ JSONResponse
            response_data = self._create_openai_json_response(extracted_text)
            logger.info(f"âœ… æˆåŠŸè¿”å›éæµå¼ç­”æ¡ˆã€‚é•¿åº¦: {len(extracted_text)}")
            return JSONResponse(content=response_data)


    async def get_models(self) -> JSONResponse:
        return JSONResponse(content={
            "object": "list",
            "data": [{"id": name, "object": "model", "created": int(time.time()), "owned_by": "Google"} for name in settings.KNOWN_MODELS]
        }
    )

--- æ–‡ä»¶è·¯å¾„: app\utils\__init__.py ---



--- æ–‡ä»¶è·¯å¾„: app\utils\sse_utils.py ---

import json
import time
from typing import Dict, Any, Optional

DONE_CHUNK = b"data: [DONE]\n\n"

def create_sse_data(data: Dict[str, Any]) -> bytes:
    """å°†å­—å…¸æ ¼å¼çš„æ•°æ®è½¬æ¢ä¸º SSE æ ¼å¼çš„å­—èŠ‚ä¸²"""
    return f"data: {json.dumps(data)}\n\n".encode('utf-8')

def create_chat_completion_chunk(
    request_id: str,
    model: str,
    content: str,
    finish_reason: Optional[str] = None
) -> Dict[str, Any]:
    """åˆ›å»ºä¸ OpenAI å…¼å®¹çš„æµå¼å“åº”æ•°æ®å—"""
    
    # æ„é€  delta
    delta = {"content": content}
    
    choice = {
        "index": 0,
        "delta": delta,
        "finish_reason": finish_reason
    }

    # ç§»é™¤ finish_reason ä¸º None çš„é”®
    if finish_reason is None:
        choice.pop("finish_reason")

    return {
        "id": request_id,
        "object": "chat.completion.chunk",
        "created": int(time.time()),
        "model": model,
        "choices": [choice]
    }


